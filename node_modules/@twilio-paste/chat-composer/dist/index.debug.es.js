var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../../../node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../../../node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// src/ChatComposer.tsx
var import_deepmerge = __toESM(require_cjs());
import * as React3 from "react";
import { Box as Box2 } from "@twilio-paste/box";
import {
  LexicalComposer,
  ErrorBoundary,
  ContentEditable,
  RichTextPlugin,
  OnChangePlugin,
  HistoryPlugin
} from "@twilio-paste/lexical-library";
import { StylingGlobals } from "@twilio-paste/styling-library";

// src/styles.ts
import { EmotionCSS } from "@twilio-paste/styling-library";
var chatComposerLexicalStyles = EmotionCSS`
.paste-chat-composer-paragraph {
  margin: 0;
  position: relative;
}

.paste-chat-composer-content-editable:focus {
  outline: none;
}
`;

// src/AutoLinkPlugin.tsx
import * as React from "react";
import { AutoLinkPlugin as LexicalAutoLinkPlugin } from "@twilio-paste/lexical-library";
var URL_MATCHER = /(?:(?:https?:\/\/(?:www\.)?)|(?:www\.))[\w#%+.:=@~-]{1,256}\.[\d()A-Za-z]{1,6}\b[\w#%&()+./:=?@~-]*/;
var EMAIL_MATCHER = /(?:(?:[^\s"(),.:;<>@[\\\]]+(?:\.[^\s"(),.:;<>@[\\\]]+)*)|(?:".+"))@(?:(?:\[(?:\d{1,3}\.){3}\d{1,3}])|(?:(?:[\dA-Za-z\-]+\.)+[A-Za-z]{2,}))/;
var MATCHERS = [
  (text) => {
    const match = URL_MATCHER.exec(text);
    return match && {
      index: match.index,
      length: match[0].length,
      text: match[0],
      url: match[0]
    };
  },
  (text) => {
    const match = EMAIL_MATCHER.exec(text);
    return match && {
      index: match.index,
      length: match[0].length,
      text: match[0],
      url: `mailto:${match[0]}`
    };
  }
];
var AutoLinkPlugin = () => {
  return /* @__PURE__ */ React.createElement(LexicalAutoLinkPlugin, { matchers: MATCHERS });
};
AutoLinkPlugin.displayName = "AutoLinkPlugin";

// src/PlaceholderWrapper.tsx
import * as React2 from "react";
import { Box } from "@twilio-paste/box";
var PlaceholderWrapper = ({ placeholder, element }) => /* @__PURE__ */ React2.createElement(
  Box,
  {
    position: "absolute",
    top: "space30",
    left: "space40",
    right: "space40",
    display: "flex",
    alignItems: "center",
    color: "colorTextWeak",
    pointerEvents: "none",
    userSelect: "none",
    fontStyle: "italic",
    element
  },
  placeholder
);
PlaceholderWrapper.displayName = "PlaceholderWrapper";

// src/helpers.ts
import { AutoLinkNode, $getRoot, $createParagraphNode, $createTextNode } from "@twilio-paste/lexical-library";
var renderInitialText = (text) => {
  const root = $getRoot();
  if (root.getFirstChild() === null) {
    const paragraph = $createParagraphNode();
    paragraph.append($createTextNode(text));
    root.append(paragraph);
  }
};
var baseConfig = {
  theme: {
    paragraph: "paste-chat-composer-paragraph"
  },
  nodes: [AutoLinkNode]
};

// src/ChatComposer.tsx
var ChatComposer = React3.forwardRef(
  ({
    children,
    element = "CHAT_COMPOSER",
    onChange,
    placeholder = "",
    initialValue,
    config,
    maxHeight,
    disabled,
    ...props
  }, ref) => {
    const baseConfigWithEditorState = {
      ...baseConfig,
      editable: disabled ? false : true,
      editorState: initialValue ? () => renderInitialText(initialValue) : void 0
    };
    return /* @__PURE__ */ React3.createElement(
      Box2,
      {
        flexGrow: 1,
        ref,
        element,
        position: "relative",
        transition: "background-color 100ms ease-in,box-shadow 100ms ease-in,color 100ms ease-in",
        paddingY: "space30",
        paddingX: "space40",
        borderRadius: "borderRadius20",
        _focusWithin: { boxShadow: "shadowFocus" },
        overflowY: "scroll",
        maxHeight,
        disabled,
        "aria-disabled": disabled,
        _disabled: {
          color: "colorTextWeaker",
          backgroundColor: "colorBackground"
        }
      },
      /* @__PURE__ */ React3.createElement(StylingGlobals, { styles: chatComposerLexicalStyles }),
      /* @__PURE__ */ React3.createElement(LexicalComposer, { initialConfig: (0, import_deepmerge.default)(baseConfigWithEditorState, config) }, /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(
        RichTextPlugin,
        {
          contentEditable: /* @__PURE__ */ React3.createElement(ContentEditable, { ...props, className: "paste-chat-composer-content-editable" }),
          placeholder: /* @__PURE__ */ React3.createElement(PlaceholderWrapper, { element: `${element}_PLACEHOLDER_WRAPPER`, placeholder }),
          ErrorBoundary
        }
      ), onChange && /* @__PURE__ */ React3.createElement(OnChangePlugin, { onChange }), /* @__PURE__ */ React3.createElement(HistoryPlugin, null), /* @__PURE__ */ React3.createElement(AutoLinkPlugin, null), children))
    );
  }
);
ChatComposer.displayName = "ChatComposer";
export {
  ChatComposer
};
